//https://sudonull.com/post/100926-Using-color-spaces-in-ATTiny13a-for-WS2811

//////////////////////////////////////////////////////////////	   2� + 3� 52 �	      ..///////////////////////////////////////////////////////////////////////
#define F_CPU 9600000UL		//					//					������������ �������� ������������	��� ws2811				//
#include <avr/io.h>			//					//		Attiny13a, Fuses =0xFF7A, CLK=9.6 MHz, Flash=476b, SRAM=42b, EEPROM=0b	//
#include <avr/pgmspace.h>	//					//											 �����: Dolphin, 25.02.2015 17:00	//
#include <util/delay.h>		//					////////////////////////////////////////////////////////////////////////////////////////////////
#define	LedMax 14			// ���������� ����������� �� �����																	//
#define OutBitsConfig 0b11	// ����� ����� ������ PB0, PB1																		//
register volatile uint8_t	LED_Byte		asm("r4"),		LED_Mask_Off	asm("r6"),	LED_Mask_On		asm("r8"),			//
							HUE_SectOffs	asm("r7"),		HUE_Sect		asm("r9"),	HUE_Byte		asm("r11");			//
register volatile int8_t	HUE_Delta		asm("r5"),		Lum				asm("r10");										//
struct c_RGB {	uint8_t g;	// ��������� ��������� GRB (������� ��� WS2811)														//
				uint8_t r;																									//
				uint8_t b;	};//   �               �              �               �                �               �               �               �	        // HUE (0GRB)			//
const uint8_t _Tab[]PROGMEM ={0,0,2,0, 0,1,2,0, 0,2,2,0, 0,2,0,0, 0,2,0,2, 0,0,0,2, 0,0,2,2, 0,0,2,0};	// ( 32 ���� flash )		//
//								  g  r  b	   g  r  b	      g  r  b	g  r  b	  g  r  b	    g  r  b	      g  r  b	g  r  b						//
c_RGB LEDBuf[LedMax]={{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},	//	����� �������� (GRB)	   ( 42 ����� SRAM )	//
					  {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}};	////////////////////////////////////////////////////////
void inline LED_Out(uint8_t* LED_Data)											//	     ������� �������� ������ WS2811			//
{																				//	� ���������� - ��������� �� ��������� GRB	//
	for (uint8_t Byte_Pos=0; Byte_Pos<3; Byte_Pos++){				 //////////////////    ( 48 ���� ���� ) (30 ���)     /////////////////////
		LED_Byte=*LED_Data++;										//														//
		asm volatile(	"	ldi   R16,8		\n\t"					//				             Connection notes:					//
						"NxtBit:			\n\t"					//														//
						"	out   0x18,R8	\n\t"	//  PB <- 1  		//				(PB0) 									//
						"	nop				\n\t"					//			------------------------- ( ws2811(0.0))  .. (ws2811(0.13))	//
						"	nop				\n\t"					//		      |           _____________							//
						"	sbrs  R4,7		\n\t"   				//		     -----------|		      |								//
						"	out   0x18,R6	\n\t"	//  PB <- 0		//		    _______| Attiny 13A  |								//
						"	lsl   R4		\n\t" 					//		   |	      |			    |								//
						"	nop				\n\t"					//		  |          |			   |								//
						"	nop				\n\t"					//		 |          |			  |								//
						"	out   0x18,R6	\n\t"	//  PB <- 0		//	       |          ----------------------								//
						"	dec   R16		\n\t"					//	      |													//
						"	brne  NxtBit	\n\t");					//	     |	  (PB1) 											//
	}																//	    -----------------	( ws2811(1.0))  .. (ws2811(1.13)) 				//
}																	//														//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Fill_LED(uint8_t HUE, uint8_t* LED_Data)						//		������� �������������� ��������� ������������		//
{																	//	� ���������� - HUE (0..255), � ��������� �� ��������� GRB	//
	uint8_t SignFlag=0;												//					   ( 290 ���� ���� ) (~1� + 4�)			//
	HUE_Sect = HUE>>5;												//	������� ����� ������� (���� �� 32),						//
	HUE_SectOffs = (HUE - (HUE_Sect<<5));							//	� �������� � �������    (������� �� �������)				//
	HUE_Byte=(HUE_Sect<<2)+1;										//	����������� ����� ������� � ������ �������.				//
	for (uint8_t Byte_Pos=0; Byte_Pos<3; Byte_Pos++){				//	���� ��������� ��������� GRB							//
		*LED_Data =(pgm_read_byte(&_Tab[HUE_Byte]) << 6);			//	�������� ���������� � ������������ ������� �� �������	//
		HUE_Delta = pgm_read_byte(&_Tab[HUE_Byte+4])-pgm_read_byte(&_Tab[HUE_Byte]);//		�������� ������ �������			//
		if (HUE_Delta < 0) {										//	���� ������ �������������,								//
			SignFlag = 1;											//		�� ��������� ���� �����							//
			HUE_Delta = -HUE_Delta;}								//		� ���������� ����	( Delta = abs(Delta)	)				//
		if (HUE_Delta != 0)	HUE_Delta = HUE_SectOffs << HUE_Delta;	//	����������� �������� ������� ������� �� ������.			//
		if (SignFlag) {												//	���� ������ �������������,								//
			*LED_Data -= HUE_Delta;									//		������� �������� ����������,						//
			SignFlag = 0;}											//		� ��������� ���� ����� ������,						//
		else *LED_Data += HUE_Delta;								//		����� �������� �������� � �����������.				//
		if (Lum<0)													//	�������� �������,										//
			 (-Lum > *LED_Data) ? *LED_Data = 0 : *LED_Data += Lum;	//		����������� ������ ������							//
		else *LED_Data += Lum;										//		����� ������� � ����������� ������������			//
		HUE_Byte++;													//	���������� ������ ��� ������� ��������� ����������,		//
		LED_Data++;													//	� �������� � � �������									//
	}																//														//
}//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(void)														//			( 118 ���� ����, �� ������ ������ ������� )		//
{	asm("cli""\n\t");												//							(15 ���)						//
	DDRB = LED_Mask_On = OutBitsConfig; LED_Mask_Off = 0; 			//														//
	uint8_t	Shift = 0;	uint8_t	Sector = 0;							//	�������� � ������ - ��� ������������					//
	int8_t Dir = 1;	Lum = 0;										//	������� ����� �������� (�������� -127...127)				//
	while(1)														//	Dir -	���������� ������� ��� ������������	 				//
	{																//														//
		for (uint8_t i=0;i<7;i++)	{								//														//
			Fill_LED(((i+Sector)<<5)+Shift,(uint8_t*)&LEDBuf[i]);	//	������ � �������� ������								//
//			LEDBuf[i+7]=LEDBuf[i];										//	� ����� �� ������ ��������								//
			LEDBuf[13-i]=LEDBuf[i];									//	��� ���������� ��������� ������������ ������, �� �����		//
		}															//														//
		for (uint8_t i=0; i<LedMax; i++)							//	������ ����� �� ����� WS2811							//
			LED_Out((uint8_t*)&LEDBuf[i]);							//														//
		_delay_ms(30);												//														//
		Shift++;if (Shift==32) {Shift=0;Sector++;}					//	������ ����� �������� � ������������					//
		Lum+=Dir; if ((Lum==127)||(Lum==-127)) Dir=-Dir;			//	� ������� ( ����������� ������ �������� ������ )			//
	}																//						(c) by DolphIn (2015)  (#101546015)	//
}//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////